package com.japharr.studentrest.service;

import com.japharr.studentrest.entity.Student;
import com.japharr.studentrest.entity.StudentParametersMapper;
import com.japharr.studentrest.entity.StudentRowMapper;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.pgclient.PgConnectOptions;
import io.vertx.sqlclient.*;
import io.vertx.sqlclient.templates.SqlTemplate;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class StudentService {
    private static final String DROP_TABLE_SQL = "drop table if exists student";
    private static final String CREATE_TABLE_SQL = "create table student(id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " +
        "first_name varchar(255), last_name varchar(255), age int, course varchar(255))";
    private static final String INSERT_TABLE_SQL = "INSERT INTO student (first_name, last_name, age, course) " +
        "VALUES (#{first_name},#{last_name},#{age},#{course}) RETURNING id, first_name, last_name, age, course ";
    private static final String UPDATE_TABLE_SQL = "UPDATE student SET first_name=#{first_name}, last_name=#{last_name}, " +
        "age=#{age}, course=#{course} WHERE id = #{id} RETURNING id, first_name, last_name, age, course";
    private static final String SELECT_ALL_SQL = "SELECT * FROM student";
    private static final String SELECT_ONE_SQL = "SELECT * FROM student WHERE id = #{id}";
    private static final String DELETE_ONE_SQL = "DELETE FROM student WHERE id = #{id}";
    private final Pool pool;

    private StudentService(Vertx vertx) {
        PgConnectOptions options = new PgConnectOptions()
            .setPort(5432)
            .setHost("localhost")
            .setDatabase("vertx_test")
            .setUser("devuser")
            .setPassword("pass123");

        this.pool = Pool.pool(vertx, options, new PoolOptions().setMaxSize(4));
    }

    public void initData(Handler<AsyncResult<RowSet<Row>>> handler) {
        SqlTemplate<Map<String, Object>, RowSet<Row>> insertTemplate = SqlTemplate
            .forQuery(pool, INSERT_TABLE_SQL);

        List<Student> testList = List.of(new Student("John", "Thomas", 20, "Computer Science")
            , new Student( "Harry", "Porter", 18, "Statistics"));

        pool.query(DROP_TABLE_SQL).execute()
            .compose(r -> pool.query(CREATE_TABLE_SQL)
                .execute())
            .compose(r -> insertTemplate
                .mapFrom(StudentParametersMapper.INSTANCE)
                .executeBatch(testList))
            .onComplete(handler)
            .onFailure(Throwable::printStackTrace);
    }

    public static StudentService init(Vertx vertx) {
        return new StudentService(vertx);
    }

    public void close(Handler<AsyncResult<Void>> var1) {
        pool.close(var1);
    }

    public void findAll(Handler<AsyncResult<List<Student>>> handler) {
        SqlTemplate<Map<String, Object>, RowSet<Row>> template = SqlTemplate
            .forQuery(pool, SELECT_ALL_SQL);

        template
            .mapTo(StudentRowMapper.INSTANCE)
            .execute(Map.of())
            .onComplete( r-> {
                if(r.succeeded()) {
                    List<Student> students = new ArrayList<>();
                    r.result().forEach(students::add);
                    handler.handle(Future.succeededFuture(students));
                } else {
                    handler.handle(Future.failedFuture(r.cause()));
                }
            });
    }

    public void findOne(int id, Handler<AsyncResult<Student>> handler) {
        SqlTemplate<Map<String, Object>, RowSet<Row>> template = SqlTemplate
            .forQuery(pool, SELECT_ONE_SQL);

        template.mapTo(StudentRowMapper.INSTANCE)
            .execute(Map.of("id", id)).onComplete( r-> {
            if(r.succeeded()) {
                if(r.result().size() > 0) {
                    List<Student> students = new ArrayList<>();
                    r.result().forEach(students::add);
                    handler.handle(Future.succeededFuture(students.get(0)));
                } else {
                    handler.handle(Future.failedFuture("student not found"));
                }
            } else {
                handler.handle(Future.failedFuture(r.cause()));
            }
        });
    }

    public void create(Student student, Handler<AsyncResult<Student>> handler) {
        SqlTemplate<Map<String, Object>, RowSet<Row>> insertTemplate = SqlTemplate
            .forQuery(pool, INSERT_TABLE_SQL);

        insertTemplate
            .mapFrom(StudentParametersMapper.INSTANCE)
            .mapTo(StudentRowMapper.INSTANCE)
            .execute(student).onComplete(r -> {
            if(r.succeeded()) {
                List<Student> students = new ArrayList<>();
                r.result().forEach(students::add);
                handler.handle(Future.succeededFuture(students.get(0)));
            } else {
                handler.handle(Future.failedFuture(r.cause()));
            }
        });
    }

    public void update(int id, Student updated, Handler<AsyncResult<Student>> handler) {
        SqlTemplate<Map<String, Object>, RowSet<Row>> updateTemplate = SqlTemplate
            .forQuery(pool, UPDATE_TABLE_SQL);

        findOne(id, r -> {
            Student exist = r.result();
            if(exist != null) {
                exist.setFirstName(updated.getFirstName());
                exist.setLastName(updated.getLastName());
                exist.setAge(updated.getAge());
                exist.setCourse(updated.getCourse());
                updateTemplate
                    .mapFrom(StudentParametersMapper.INSTANCE)
                    .mapTo(StudentRowMapper.INSTANCE)
                    .execute(exist).onComplete(rx -> {
                    if(rx.succeeded()) {
                        List<Student> students = new ArrayList<>();
                        rx.result().forEach(students::add);
                        handler.handle(Future.succeededFuture(students.get(0)));
                    } else {
                        handler.handle(Future.failedFuture(rx.cause()));
                    }
                });
            } else {
                handler.handle(Future.failedFuture("Student of id does not exist"));
            }
        });
    }

    public void deleteOne(int id, Handler<AsyncResult<RowSet<Void>>> handler) {
        SqlTemplate<Map<String, Object>, SqlResult<Void>> template = SqlTemplate
            .forUpdate(pool, DELETE_ONE_SQL);

        template.execute(Map.of("id", id)).onComplete( r-> {
            if(r.succeeded()) {
                handler.handle(Future.succeededFuture());
            } else {
                handler.handle(Future.failedFuture(r.cause()));
            }
        });
    }
}
